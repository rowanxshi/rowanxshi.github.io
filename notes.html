<html>
<head>
	<meta charset="utf-8"/>
	<link rel="stylesheet" href="responsive.css">
	<title>Rowan Shi</title>
</head>

<body>
	<header>
		<div id=header-container>
			<span id=name>Rowan Shi</span>
			<input type=checkbox id=menu-open hidden></input>
			<label for=menu-open>
				<div id=hamburger><hr></hr></div>
			</label>
			<nav>
				<a href="index.html#home">home</a>
				<a href="index.html#research">research</a>
			</nav>
			<div class=clear></div>
		</div>
	</header>
	
	<input type=checkbox id=dark-light hidden>
	<label id=theme-toggle for=dark-light><div id=toggle-inner></div></label>

	<main id=notes>
		<div class=content>
			<div class=section>Contents</div>
			<ul>
				<li><a href=#package>Writing a package in Julia</a></li>
				<li><a href=#setup>My computing setup</a></li>
			</ul>
		</div>
		<div class="content" id=package>
			<div class="section">Writing a package in Julia</div>
			<p>In tandem with <a href="papers/cdc.pdf">one of my projects</a>, I wrote a <a href="https://github.com/rowanxshi/CDCP.jl">Julia package</a> implementing its central solution methods. This undertaking was the first time I wrote a Julia package (the larger project itself the first time I really used Julia).</p>
			
			<p>Since I had never written a package in Julia (or indeed in any other language), it was a learning experience &mdash; especially for the under-the-hood processes with which software engineers are undoubtedly familiar: wrangling workflows; git and version control; packages and dependencies; documenting and testing. While I learned a lot, I will focus only on the mechanics of starting and developing a Julia package here. (Maybe more to come on the other topics later!)</p>
			
			<p></p>
			<details>
			<summary>Read more</summary>
			<p>A package is <i>functionally</i> no different from any code project in the sense that it just runs code. <i>Conceptually</i>, packages tend to be centred around building and making available a core set of functionalities to use repeatedly &mdash; hopefully for yourself, your collaborators, or even strangers trying to solve similar problems. For this reason, code for a package should be written in Julia <i>modules</i>, exporting only the key functionalities for general use.</p>
			
			<p>For brevity, I'll first list the basic steps to get a new package going, then discuss them in more detail.</p>
			<ol>
				<li>Open Julia, enter Pkg mode (by typing <code>]</code>).</li>
				<li>Initiate your package, say "NewPackage", by typing <code>generate NewPackage</code>. Doing so will create a NewPackage folder in the current working directory.</li>
				<li>Create a git repository at some online host like GitHub, probably called NewPackage.jl, and push the contents of the NewPackage folder.</li>
				<li>NewPackage can now be added to Julia's default <i>environment</i> &mdash; tell Julia about it by typing something like <code>add https://github.com/rowanxshi/NewPackage.jl</code> in Pkg mode. Julia now knows to get NewPackage from the online git repository.</li>
				<li>We probably want to make changes to NewPackage locally before publishing them online. In Pkg mode, type <code>dev NewPackage</code>. Julia will copy the package files for local development (usually somewhere like ~/.julia/dev/NewPackage), then tell the default environment to load NewPackage from this local version rather than the version hosted online.</li>
				<li>We now have two local versions on the package: one we created with <code>generate</code> and one we created with <code>dev</code>. At this point, the first serves no purpose (it isn't being watched by Julia, for example) so we can delete it. I personally created a symbolic link from this location to the local development copy, since the original location was more convenient for my file management purposes.</li>
				<li>Now, we can make any changes we want to the local copy. To incorporate the changes, update the package by typing something like <code>up NewPackage</code> in Pkg mode, then restart Julia. When satisfied with changes, commit and push them so they can be available for everyone from the online hosted location.</li>
			</ol>
			
			<p>The process above is a bit convoluted. For me, the multiple copies (created with <code>generate</code> and <code>dev</code>) were very confusing. I am not sure if there is a way to get the balling rolling in a more efficient way in Julia, or if it's standard with other languages to create multiple local copies of a project during the initiation process.</p>
			
			<p>I'll close with a few final comments on the practicalities of package development.</p>
			<ul>
				<li><b><i>Dependencies.</i></b> Each time before working on the package, activate its environment by typing <code>activate .</code> in Pkg mode while in the package's directory. If done correctly, the Pkg prompt will switch to <code>(NewPackage) pkg></code> and track dependencies. For example, suppose the package relies on LinearAlgebra.jl. After activating the package's environment, typing <code>add LinearAlgebra</code> in Pkg mode means that Julia will automatically record that your package depends on LinearAlgebra. When others download your package, Julia will know to also download LinearAlgebra.</li>
				<li><b><i>Prototyping.</i></b> I like using Pluto.jl to prototype small snippets of changes before directly editing the package contents. Its reactivity is a real convenience for quickly seeing whether ideas will work.</li>
				<li><b><i>Revise.jl.</i></b> A package recommended by essentially everyone, it allows real-time updates to local packages rather than having to open a fresh Julia session to see changes reflected.</li>
				<li><b><i>Testing.</i></b> Nearly every serious package has run tests to check its functionality. To test a package, write a "NewPackage/test/runtests.jl" file (creating the test directory if necessary). Then, you can ask Julia to run the runtests.jl file by typing <code>test NewPackage</code> in Pkg mode.</li>
			</ul>
			</details>
		</div>
		<div class=content id=setup>
			<div class=section>My computing setup</div>
			<p>As a trade economist, I spend my fair share of time cranking through theory, but I spend an equal amount of time coding quantitative computations, mucking with data, or (recently) even teaching online. My computing devices are a central determinant to not only my work's success, but also my happiness, since I spend so much with them. I therefore approach choosing my setup with appropriate seriousness!</p>
			<p>My current devices are not only frictionless to use, but also joyful. I do my work on two main devices: a large iPad Pro and a Mac mini desktop computer.</p>
			<p></p>
			<details>
			<summary>Read more</summary>
			<p>I bought the first generation iPad Pro soon after its release, taking an early adopter risk that paid off. The iPad is functional both as "digital replacement paper" in portrait orientation as well as a "light computer" in landscape orientation. The first use case is the real hero, though: it is a delight to read papers or work through theory with the iPad and its accompanying stylus. Eliminating paper from my life is a seemingly small benefit that has actually had a huge impact: the digital medium creates possibilities that couldn't be accomplished with physical paper. I never misplace my notes or have to rifle through physical copies of papers. Everything is instantly searchable, including handwritten annotations. I can open the same note in multiple windows, for example to conveniently reference an equation from an earlier page in one window while rewriting it with some substitution on a later page in another window. The stylus is infinitely precise, so I can easily add annotations in the tiniest available space by just zooming in. Finally, I can always use the iPad in landscape orientation to perform light computer tasks, like typing up documents, responding to emails, or managing my calendar. These activities are made even smoother with my external mouse and keyboard, which connect easily to the iPad, but I will talk more about those a bit later.</p>
			<p>The Mac mini is the primary computing device of my setup, a role previously filled by my laptop until the laptop's screen physically separated from its body. Why did I replace it with a desktop instead of another laptop, when laptops ostensibly have the advantage of including peripherals (display, keyboard, and mouse) and being portable? As it turns out, the Mac mini does just as well, if not better, in all these areas for my context. For peripherals, I had already been using the laptop exclusively with my own external monitor, <a href=http://coolermaster.com/catalog/peripheral/keyboards/sk622-silver/>keyboard</a>, and <a href=https://www.logitech.com/en-ca/products/mice/mx-anywhere-3.910-005985.html>mouse</a>, all of which I preferred to the built-in options by a landslide. Why purchase computing power bundled with peripherals that I wouldn't use when I could instead concentrate on more computing power? The Mac mini is also highly portable &mdash; I can easily slip the Mac mini in my regular bag, together with my keyboard and mouse, to bring with me to the office, a coffee shop, or on travel. The only seeming obstacle to portability was finding a display solution, which I remedied by simply <a href=https://astropad.com/product/lunadisplay/>using my iPad as the display</a> with a pleasingly solid yet foldable <a href=http://twelvesouth.com/products/compass-pro>stand</a>. Why not, if I'm likely bringing my iPad with me anyway?</p>
			<p>At first, I admit I was not sure if my Mac-mini-as-a-laptop-replacement scheme would work. However, after several months now of using it daily, I can confidently label the experiment a success. At home, I get the full desktop performance and experience. On the go, it takes one or two extra seconds to pack up (Mac, mouse, keyboard, iPad, and iPad stand), but the benefits far outweigh this cost. The setup is wonderfully modular, with all components working seamlessly together. I can use the iPad on its own as digital paper. I can pull out my mouse, keyboard, and stand to use the iPad like a light computer. If I need the desktop OS to do something more serious, like <a href=#package>Julia development</a>, I can just switch the iPad's screen to showing the Mac mini's display. As an additional underrated bonus, I use my own keyboard and mouse for everything, which I selected based on my own preferences, rather than default OEM parts.</p>
			<p>Finally, I cannot overstate the ergonomic advantages of separating the display from the keyboard. By construction, a laptop must (nearly) attach them together. The implication of a laptop's clamshell design is that, if positioning the keyboard and trackpad adequately close to one's hands, the display is far too close to the eyes. Not only is it too close, but it is too far down, which would create tension as I craned my neck downward to see the display. Having physically separated all the components of my computer from each other, I can position each at a comfortable distance.</p>
			<p>While this setup may not be for everybody, or indeed for most people, I wanted to share my strange solution in case it may be helpful to someone else. A mini-desktop-as-a-pseudo-laptop may appear at first glance like an unnecessary reinvention the wheel, but the modularity and personal customisability have made all the difference to me.</p>
			</details>
		</div>
	</main>
</body>
</html>
